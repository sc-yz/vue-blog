---
title: ES6
categories:
tags:
---

## var let const

我们就从`声明过程`，`内存分配`，`变量提升`这三点来看这三者之间的区别。

1. 声明过程

- var：遇到有 var 的作用域，在任何语句执行前都已经完成了声明和初始化，也就是变量提升而且拿到 undefined 的原因由来 function： 声明、初始化、赋值一开始就全部完成，所以函数的变量提升优先级更高
- let：解析器进入一个块级作用域，发现 let 关键字，变量只是先完成声明，并没有到初始化那一步。此时如果在此作用域提前访问，则报错 xx is not defined，这就是暂时性死区的由来。等到解析到有 let 那一行的时候，才会进入初始化阶段。如果 let 的那一行是赋值操作，则初始化和赋值同时进行
- const、class 都是同 let 一样的道理 比如解析如下代码步骤：

{ // 没用的第一行 // 没用的第二行 console.log(a) // 如果此时访问 a 报错 a is not defined let a = 1 } 步骤：

发现作用域有 let a，先注册个 a，仅仅注册 没用的第一行 没用的第二行 a is not defined，暂时性死区的表现 假设前面那行不报错，a 初始化为 undefined a 赋值为 1 对比于 var，let、const 只是解耦了声明和初始化的过程，var 是在任何语句执行前都已经完成了声明和初始化，let、const 仅仅是在任何语句执行前只完成了声明。

2. 内存分配

- var，会直接在栈内存里预分配内存空间，然后等到实际语句执行的时候，再存储对应的变量，如果传的是引用类型，那么会在堆内存里开辟一个内存空间存储实际内容，栈内存会存储一个指向堆内存的指针

- let，是不会在栈内存里预分配内存空间，而且在栈内存分配变量时，做一个检查，如果已经有相同变量名存在就会报错

- const，也不会预分配内存空间，在栈内存分配变量时也会做同样的检查。不过 const 存储的变量是不可修改的，对于基本类型来说你无法修改定义的值，对于引用类型来说你无法修改栈内存里分配的指针，但是你可以修改指针指向的对象里面的属性

3. 变量提升

let const 和 var 三者其实会存在变量提升

- let 只是创建过程提升，初始化过程并没有提升，所以会产生暂时性死区,定义在使用之后报错。
- var 的创建和初始化过程都提升了，所以在赋值前访问会得到 undefined function 的创建、初始化、赋值都被提升了

## class contructor super extend

类没有变量提升

### super 关键字

用于访问和调用对象父类上的函数，可以调用父类的构造函数，也可以调用父类的普通函数。

在子类构造函数中使用 this，需要提前使用 super()

## 相关视频

[b 站黑马](https://www.bilibili.com/video/BV1Kt411w7MP?p=40)
